"""
A fast solution for this one requires knowing about
[the union-find data structure](https://en.wikipedia.org/wiki/Disjoint-set_data_structure).

The idea is simple: we maintain a mapping between each point and its parent.
Each parent represents a cluster, thus points mapping to the same parent are in the same cluster.

We then have 2 operations:

    - find(x): find the top-most parent of x (parent of a parent of a parent, ...),
      remapping the parent's chain as we go to shorten the paths (path compression).
      We know if parent was previously found, since we initialize the parent dictionary to map
      each point to itself initially.
    - union(x, y): union the clusters of x and y. If x and y have the same parent,
      they are already in the same cluster, so we do nothing.
      If we need to merge the two clusters, we always attach the smaller cluster to the larger one,
      and update the size of the larger cluster accordingly.

Both of these operations will run in (roughly) constant time.

This data structure is implemented by the `UnionFind` dataclass. We pass the pairs of points
in the "closest to each other" order as an InitVar
(i.e., it will only be passed to the (autogenerated) `__init__` and `__post_init__` methods
for us to initialize the size and parent dictionaries).

Part 1 solution is simple: we take the specified number of closest pairs and union them.
The result is the product of the sizes of the 3 largest clusters.

Part 2 solution is similar: we take all pairs and union them.
The result is the product of the coordinates of the 2 points that were last connected.
We added a `last_connection` attribute to the `UnionFind` dataclass to keep track of the last connected pair.
"""

from math import prod
from typing import Optional
from itertools import product
from dataclasses import dataclass, field, InitVar

type Point = tuple[int, int, int]


def parse_input(input: str) -> list[Point]:
    return [tuple(map(int, line.split(","))) for line in input.splitlines()]


def distance(a: Point, b: Point) -> float:
    return ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2 + (a[2] - b[2]) ** 2) ** 0.5


def by_shortest_distance(a: list[Point], n: Optional[int] = 1000) -> list[(Point, Point)]:
    res = sorted(((x, y) for (x, y) in product(a, a) if x != y and x < y), key=lambda points: distance(*points))
    return res[:n] if n else res


@dataclass
class UnionFind:
    parent: dict[Point, Point] = field(default_factory=lambda: {})
    size: dict[Point, int] = field(default_factory=lambda: {})
    last_connection: Optional[tuple[Point, Point]] = None

    closest: InitVar[list[(Point, Point)]] = None

    def __post_init__(self, closest: list[(Point, Point)]):
        for x, y in closest:
            self.parent[x] = x
            self.parent[y] = y
            self.size[x] = 1
            self.size[y] = 1

    def find(self, x: Point) -> Point:
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]

    def union(self, x: Point, y: Point):
        x_parent, y_parent = self.find(x), self.find(y)
        if x_parent == y_parent:
            return

        # maintain invariant that x_parent is the larger tree
        if self.size[x_parent] < self.size[y_parent]:
            x_parent, y_parent = y_parent, x_parent

        # attach y_parent to x_parent, and increase the size of x_parent accordingly
        self.parent[y_parent] = x_parent
        self.size[x_parent] += self.size[y_parent]

        # needed for p2, since this will allow us to see the last connected pair
        self.last_connection = (x, y)


def p1(input: list[Point], n: int = 1000) -> int:
    closest = by_shortest_distance(input, n=n)
    uf = UnionFind(closest=closest)
    for x, y in closest:
        uf.union(x, y)
    return prod(sorted(uf.size.values(), reverse=True)[:3])


def p2(input: list[Point]) -> int:
    closest = by_shortest_distance(input, n=None)
    uf = UnionFind(closest=closest)
    for x, y in closest:
        uf.union(x, y)
    return uf.last_connection[0][0] * uf.last_connection[1][0]


if __name__ == "__main__":
    test_input = parse_input("""162,817,812
57,618,57
906,360,560
592,479,940
352,342,300
466,668,158
542,29,236
431,825,988
739,650,466
52,470,668
216,146,977
819,987,18
117,168,530
805,96,715
346,949,466
970,615,88
941,993,340
862,61,35
984,92,344
425,690,689
""")

    with open("inputs/d08.txt") as f:
        input = parse_input(f.read())

    assert p1(test_input, n=10) == 40
    p1_ans = p1(input, n=1000)
    assert p1_ans == 46398
    print(f"p1: {p1_ans}")

    assert p2(test_input) == 25272
    p2_ans = p2(input)
    assert p2_ans == 8141888143
    print(f"p2: {p2_ans}")
